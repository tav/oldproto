#! /usr/bin/env python2.7

# Public Domain (-) 2008-2012 The Espra Authors.
# See the Espra UNLICENSE file for details.

"""Build script for Proto Espra."""

from cStringIO import StringIO
from hashlib import sha1
from inspect import getargspec
from os import chmod, mkdir
from os.path import dirname, exists, join, realpath
from shutil import rmtree
from sys import argv, exit, platform
from time import sleep
from urllib import urlopen
from zipfile import ZipFile

from plumbum import FG, local
from plumbum.cmd import ant, assetgen
from yaml import load as parse_yaml

# ------------------------------------------------------------------------------
# Print Utilities
# ------------------------------------------------------------------------------

def error(msg):
    print "\033[1;31m!! ERROR: %s !!\033[0m" % msg
    exit(1)

def start(msg):
    print "\033[1;34m>> %s\033[0m" % msg

def progress(msg):
    print "\033[1;30m## %s\033[0m" % msg

def success(msg):
    print "\033[32m** %s\033[0m" % msg

# ------------------------------------------------------------------------------
# Platform Detection
# ------------------------------------------------------------------------------

if platform.startswith('darwin'):
    PLATFORM = 'darwin'
elif platform.startswith('linux'):
    PLATFORM = 'linux'
else:
    error("The %r operating system isn't currently supported" % platform)

# ------------------------------------------------------------------------------
# YAML Config Handling
# ------------------------------------------------------------------------------

def get_yaml_conf(filename):
    f = open(join(dirname(__file__), filename), 'rb')
    conf = parse_yaml(f)
    f.close()
    return conf

# ------------------------------------------------------------------------------
# Global Constants
# ------------------------------------------------------------------------------

META = get_yaml_conf('meta.yaml')

GAE_SDK_FILES = {
    'java': "appengine-java-sdk-%s.zip" % META['gae-version'],
    'go': "go_appengine_sdk_%s_amd64-%s.zip" % (PLATFORM, META['gae-version']),
    'python': "google_appengine_%s.zip" % META['gae-version']
}

GAE_SDK_PATH_ROOT = "http://googleappengine.googlecode.com/files/"
SCRIPT_ROOT = dirname(__file__)

# -----------------------------------------------------------------------------
# Command Decorator
# -----------------------------------------------------------------------------

COMMANDS = {}

def register(func):
    COMMANDS[func.__name__.replace('_', '-')] = (getargspec(func), func)

# ------------------------------------------------------------------------------
# Utility Functions
# ------------------------------------------------------------------------------

def get_path(*path):
    return join(SCRIPT_ROOT, *path)

# ------------------------------------------------------------------------------
# Download Handlers
# ------------------------------------------------------------------------------

def download_gae_sdk(runtime):

    name = "%s App Engine SDK" % runtime.title()
    filename = GAE_SDK_FILES[runtime]
    target_dir = get_path('.appengine_%s_sdk' % runtime)
    version_file = join(target_dir, 'VERSION')

    if runtime == 'java':
        if exists(join(
            target_dir, 'lib', 'user',
            'appengine-api-labs-%s.jar' % META['gae-version']
            )):
            success("%s is up-to-date." % name)
            return
    elif exists(version_file):
        sdk_version_file = open(version_file, 'rb')
        sdk_version = sdk_version_file.readline().split()
        sdk_version = sdk_version and sdk_version[-1] or ''
        sdk_version_file.close()
        if sdk_version == '"%s"' % META['gae-version-name']:
            success("%s is up-to-date." % name)
            return

    start("Installing %s" % name)

    if exists(target_dir):
        progress("Removing Existing %s %s" % (name, sdk_version))
        rmtree(target_dir)

    progress("Downloading %s..." % name)

    try:
        req = urlopen(GAE_SDK_PATH_ROOT + filename)
        if runtime == 'go':
            checksum = META['go-%s-sdk' % PLATFORM]
        else:
            checksum = META['%s-sdk' % runtime]
        sdk_file = validate_download(req, checksum)
    except Exception, err:
        error("Couldn't Download the %s: %r" % (name, err))

    progress("Extracting %s" % name)
    try:
        mkdir(target_dir, 0777)
        sdk_zip = ZipFile(sdk_file)
        for iname in sdk_zip.namelist():
            newname = iname.split("/", 1)
            if len(newname) != 2:
                continue
            newname = newname[1]
            if not newname:
                continue
            if iname.endswith('/'):
                mkdir(join(target_dir, newname))
            else:
                target_path = join(target_dir, newname)
                newfile = open(target_path, 'wb')
                newfile.write(sdk_zip.read(iname))
                newfile.close()
                info = sdk_zip.getinfo(iname)
                if info.external_attr:
                    chmod(target_path, info.external_attr >> 16)
    except Exception, err:
        error("Couldn't Extract the %s: %r" % (name, err))

    success("%s Successfully Installed." % name)

def install_dist():

    dist_path = get_path("dist")
    if exists(dist_path):
        if exists(join(dirname(realpath(dist_path)), ".git")):
            success("A version controlled `dist` directory exists.")
            return

def validate_download(req, checksum):
    data = req.read()
    if sha1(data).hexdigest() != checksum:
        error("Mismatched checksum for downloaded file")
    return StringIO(data)

# ------------------------------------------------------------------------------
# Build
# ------------------------------------------------------------------------------

def build():
    pass

# ------------------------------------------------------------------------------
# Core Tasks
# ------------------------------------------------------------------------------

@register
def app(profile='dev', watch=False):
    """build the app files"""

    start("Building app files")

    conf_path = get_path("etc", "app", "config.yaml")

    try:
        while 1:
            conf = get_yaml_conf(conf_path)
            if not watch:
                break
            sleep(1)
    except KeyboardInterrupt:
        exit(0)

    success("App files successfully built")

@register
def deploy(app):
    """deploy a production build"""

    start("Deploying %s" % app)

    if app == 'all':
        all = 1
    else:
        all = 0

    if all or app == 'python':
        progress("Deploying the Python app")
        appcfg = local[get_path(".appengine_python_sdk", "appcfg.py")]
        with local.cwd(get_path("python")):
            appcfg["update", "."] & FG

    if all or app == 'java':
        progress("Building the Java app")
        with local.cwd(get_path("java")):
            ant["war"] & FG
        progress("Deploying the Java app")
        appcfg = local[get_path(".appengine_java_sdk", "bin", "appcfg.sh")]
        with local.cwd(get_path("java")):
            appcfg["update", "war"] & FG

    success("Finished deploying %s" % app)

@register
def install():
    """install the various dependencies"""

    for runtime in ('go', 'java', 'python'):
        download_gae_sdk(runtime)

    install_dist()

@register
def run(profile='dev'):
    """build and run a local instance"""

    start("Running servers under the %s profile" % profile)

# -----------------------------------------------------------------------------
# Script Runner
# -----------------------------------------------------------------------------

if __name__ == '__main__':
    argv = argv[1:]
    if not argv or argv[0] in ('-h', '--help', 'help'):
        out = []
        print "Usage: build [command]\n"
        print "Commands:\n"
        for cmd in sorted(COMMANDS):
            spec, func = COMMANDS[cmd]
            if spec.args:
                extra = "/%s" % '/'.join("<%s>" % arg for arg in spec.args)
            else:
                extra = ""
            out.append(("%s%s" % (cmd, extra), func.__doc__))
        max = 0
        for name, _ in out:
            spacing = len(name)
            if spacing > max:
                max = spacing
        max += 5
        for name, doc in out:
            pad = (max - len(name)) * ' '
            print "\t%s%s%s" % (name, pad, doc)
        print
        exit(0)
    for cmd in argv:
        cmd = cmd.split('/', 1)[0]
        if cmd not in COMMANDS:
            error("Couldn't find the %s command" % cmd)
    for cmd in argv:
        split = cmd.split('/')
        cmd = split.pop(0)
        spec, func = COMMANDS[cmd]
        args = filter(None, split)
        slen = len(args)
        req = len(spec.args)
        if slen > req:
            error("The %s command only takes %d arguments" % (cmd, req))
        if spec.defaults:
            req -= len(spec.defaults)
        if slen < req:
            error("The %s command requires at least %d arguments" % (cmd, req))
        func(*args)
